---
title: Leetcode 301
date: 2021-04-06 23:12:09
tags: 
cover_img:
feature_img:
categories:
- OJ 
description: Remove Invalid Parentheses 
keywords:
---
Given a string `s` that contains parentheses and letters, remove the minimum number of invalid parentheses to make the input string valid.
Return all the possible results. You may return the answer in any order.
**Example:**
```
Input: s = "()())()"
Output: ["(())()","()()()"]
```

先扫一遍要去掉多少的`(`和`)`，因为一个包含`()`的合法式子的要求是时刻`)`数量不能大于`(`，最后`()`数量应该相等。所以要去掉的`)`为从左往右扫，`)`与`(`数目之差的最大值，要去掉的`(`为`)`的数目减去要去除的数目再被`(`的数量减。
然后用dfs，对每一个括号，搜索删或者不删的两种情况。其中如果当前括号类型不够删了则不能选择删的路线。如果搜索到了已经可以判断是非法式(即`)`数目多于`(`)以及剩余括号数量不足以满足要删除的括号数量的地方要剪枝。对于小写字母不作处理。当搜到输入字符串末尾，把合法答案存在一个哈希表中。
```
int max(int a, int  b) {return a>b?a:b;}
class Solution {
public:
    vector<string> removeInvalidParentheses(string s) {
        unordered_map<string, bool> ans;
        int left = 0, right = 0, l = 0, r = 0;
        for (int i = 0; i < s.size(); i++) {
                if (s[i] == '('){
                        l++;
                } else if (s[i] == ')') {
                        r++;
                }
                if (r > l) {
                        right = max(right, r-l);
                }
        }
        left = l > (r-right) ? l-r+right: 0;
        search(ans, s, 0, 0, 0, left, right);
        vector<string> v(ans.size(), "");
        int i = 0;
        for (auto it = ans.begin(); it != ans.end(); it++, i++) {
                v[i] = it->first;
        }
        return v;
    }

    // hl: has left
    // dl: should delete left
    void search(unordered_map<string, bool> &ans, string s, int p, int hl, int hr, int dl, int dr) {
            if (hr > hl || s.size() - p < dl+dr) {
                    return;
            }
                    if (p == s.size()) {
                    if ((dl | dr) != 0)
                            return;
                    string str;
                    for (int i = 0; i < s.size(); i++) {
                            if (s[i] != ' ') {
                                    str += s[i];
                            }
                    }
                    if (ans.find(str) == ans.end()) {
                        ans[str] = true;
                    }
                    return;
            }
            switch (s[p]) {
                case '(':
                        if (dl > 0) {
                                string str = s;
                                str[p] = ' ';
                                search(ans, str, p+1, hl, hr, dl-1, dr);
                        }
                        search(ans, s, p+1,hl+1, hr, dl, dr);
                        break;
                case ')':
                        if (dr > 0) {
                                string str = s;
                                str[p] = ' ';
                                search(ans, str, p+1, hl, hr, dl, dr-1);
                        }
                        search(ans, s, p+1,hl, hr+1, dl, dr);
                        break;
                default:
                        search(ans, s, p+1, hl,hr,dl,dr);
            }
    }
};
```
这个算法可以优化的地方在于对于一串连续的相同括号，只搜索第一个即可。
