---
title: Leetcode 306
date: 2021-04-07 00:58:58
tags:
cover_img:
feature_img:
description: Additive Number
keywords:
---
[Original link](https://leetcode.com/problems/additive-number/)

Additive number is a string whose digits can form additive sequence.

A valid additive sequence should contain **at least** three numbers. Except for the first two numbers, each subsequent number in the sequence must be the sum of the preceding two.

Given a string containing only digits `'0'-'9'`, write a function to determine if it's an additive number.

Note: Numbers in the additive sequence cannot have leading zeros, so sequence `1, 2, 03` or `1, 02, 3` is invalid.

**Example:**
```
Input: "112358"
Output: true
Explanation: The digits can form an additive sequence: 1, 1, 2, 3, 5, 8. 
             1 + 1 = 2, 1 + 2 = 3, 2 + 3 = 5, 3 + 5 = 8
```

一个字符串是不是可加的，前两个数就能定下来来。因此回溯可以解该题，用`i`和`j`分别表示第一次加法的第一个和第二个加数的位数，则失败后先`j++`。等到不能维持至少三个数字的时候，`i++; j=1`。

需要注意`0`开头的数字不合法，但是`0`是合法的。因为加起来之后是不会出现`0`的，所以只要前面的两个数中的第二个不要出现`0x`即可。其实还应该检查是不是`0`开头的字符串，如果是，那么第一个数必须是`0`。对于`0`的情况，只会出现在第一次加法运算的第二个加数上，因此，只需要在第二个数长度为1失败的那次回溯只会判断它是不是`0`即可。
```
int max(int i, int j) {return i>j?i:j;}
class Solution {
public:
    bool isAdditiveNumber(string num) {
        int n = num.size();
        int i = 1, j = 1;
        string a, b;
        int pos = 0;
        int m = 0;
        while(i <= n/2) {
                while((n-i-j) >= i &&  n -i -j >= j) {
                        a = num.substr(0, i);
                        b = num.substr(i, j);
                        m = max(a.size(), b.size());
                        pos = i+j+m-1;
                        while(pos < n) {
                                if (add(a, b, num, pos, false)) {
                                        a = b;
                                        b = num.substr(pos-m+1,m);
                                } else if (add(a, b, num, pos+1, true)) {
                                        a = b;
                                        b = num.substr(pos-m+1,m + 1);
                                        pos += 1;
                                } else {
                                        break;
                                }
                                if (pos == n - 1) {
                                        return true;
                                }
                                m = max(a.size(), b.size());
                                pos += m;
                        }
                        if (num[i] == '0') {
                                break;
                       }
                        j++;
                }
                i++;
                j=1;
        }
        return false;
    }

    bool add(string a, string b, string num, int pos, bool flag) {
            string tmp = a;
            if (a.size() < b.size()) {
                    a= b;
                    b= tmp;
            }
            if (pos >= num.size())
                    return false;
            int i = a.size() - 1, j = b.size() - 1, p = pos, re = 0;
           while (j>=0) {
                re += a[i]-48+b[j]-48;
                if (num[pos]-48 != re % 10) {
                        return false;
                }
                re = re / 10;
                pos--;
                i--;
                j--;
           }
           while (i >= 0) {
                   re += a[i] - 48;
                   if (num[pos]-48 != re %10){
                           return false;
                   }
                   re = re / 10;
                   i--;
                   pos--;
           }
          return re > 0? flag && num[pos]-48==re: !flag;
    }
};
```
